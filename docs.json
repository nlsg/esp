{
  "./src/api.py": {
    "#!/usr/bin/env python3": "N/A",
    " before_request_handler(request):": "N/A",
    " root(request):": "the root node",
    " api_documentation(request):": "N/A",
    " api_gpio(request, function):": "api rout"
  },
  "./src/boot.py": {
    "#!/usr/bin/env python": "N/A",
    " do_connect(ssid, pwd):": "a safe way to connect to a network"
  },
  "./src/gpio.py": {
    "#!/usr/bin/env python3": "N/A",
    " get_pin(pin=None, **kwargs):": "get the value of a digital output pin\n    arguments:\n     - pin: the pin on which a value is read\n    return -> value of the pin",
    " read_pin(pin):": "read the value of a pin,\n    which needs to have an internal ADC\n    arguments:\n     - pin:  the pin in which the value will be read\n     - unit: the unit in which the read value should be interpreted,\n             possible units are:\n              - raw [12bit value] <",
    "ault>": "\n    ",
    " read_pt100(pin, sample_size=10, delay=.1, **kwargs):": "N/A",
    " read_ds18b20(pin):": "reads temperature from a ds18b20 or ds18b20 sensors\n    to support multiple sensors on one pin,\n    the values are returned in a dict {\"addr\": val}\n     - addr: 64bit hex address-string\n     - val:  value in degres represented as float\n\n    the data pin of the ds18b20 sensor\n    must be pulled up by a 4.7 kOhm resistor",
    " set_pin(pin, value=None, **kwargs):": "set the pin to value\n    arguments:\n     - pin:    to pin to act on\n     - value:  to set the pin to (0,1)\n               ",
    "ault value is None, in this case,": "\n    # first handle all error cases\n    pin = trying(ValueError, int, pin, lambda a: {\"error\": f\"ValueError: '{a}' is of wrong type!\"})\n    if value is not None:\n        value = trying(ValueError, int, value, lambda a: {\"error\": f\"ValueError: '{a}' is of wrong type!\"})\n    for i in [pin, value]:\n        if has(i, \"error\"):\n            return i\n\n    pin = Pin(pin, Pin.OUT)\n    if value is None:\n        value = not pin.value()\n    pin.value(value)\n    return {\"pin\": pin,\n            \"type\": \"set_pin\",\n            \"value\": pin.value()}\n\n",
    " pwm_pin(pin, freq=None, duty_u16=None, duty_ns=None, deinit=False, **kwargs):": "set pwm value of given pin\n    arguments:\n     - pin:    the pin on which a pwm value will be set\n     - freq\n    https://docs.micropython.org/en/latest/library/machine.PWM.html#machine-pwm\n    "
  },
  "./src/main.py": {
    "#!/usr/bin/env python3": "N/A"
  },
  "./src/microdot_asyncio.py": {
    "#!/usr/bin/env python": "\nmicrodot_asyncio\n----------------\n\nThe ``microdot_asyncio`` module ",
    "ines a few classes that help implement": "\ntry:\n    import uasyncio as asyncio\nexcept ImportError:\n    import asyncio\n\ntry:\n    import uio as io\nexcept ImportError:\n    import io\n\nfrom microdot import Microdot as BaseMicrodot\nfrom microdot import print_exception\nfrom microdot import Request as BaseRequest\nfrom microdot import Response as BaseResponse\n\n\n",
    " _iscoroutine(coro):": "N/A",
    " __init__(self, data):": "N/A",
    " read(self, n=-1):": "N/A",
    " readline(self):  # pragma: no cover": "N/A",
    " readexactly(self, n):  # pragma: no cover": "N/A",
    " readuntil(self, separator=b'\\n'):  # pragma: no cover": "N/A",
    " create(app, client_stream, client_addr):": "Create a request object.\n\n        :param app: The Microdot application instance.\n        :param client_stream: An input stream from where the request data can\n                              be read.\n        :param client_addr: The address of the client, as a tuple.\n\n        This method is a coroutine. It returns a newly created ``Request``\n        object.\n        ",
    " stream(self):": "N/A",
    " _safe_readline(stream):": "An HTTP response class.\n\n    :param body: The body of the response. If a dictionary or list is given,\n                 a JSON formatter is used to generate the body.\n    :param status_code: The numeric HTTP status code of the response. The\n                        ",
    "ault is 200.": "N/A",
    "ault is \"OK\" for responses with a 200 status code and": "\n    async ",
    " write(self, stream):": "N/A",
    " start_server(self, host='0.0.0.0', port=5000, debug=False):": "Start the Microdot web server as a coroutine. This coroutine does\n        not normally return, as the server enters an endless listening loop.\n        The :func:`shutdown` function provides a method for terminating the\n        server gracefully.\n\n        :param host: The hostname or IP address of the network interface that\n                     will be listening for requests. A value of ``'0.0.0.0'``\n                     (the ",
    "ault) indicates that the server should listen for": "N/A",
    "ault is": "N/A",
    "ault is ``False``.": "N/A",
    " index():": "\n        asyncio.run(self.start_server(host=host, port=port, debug=debug))\n\n    ",
    " main():": "\n        self.debug = debug\n\n        async ",
    " serve(reader, writer):": "N/A",
    " awrite(self, data):": "N/A",
    " aclose(self):": "N/A",
    " run(self, host='0.0.0.0', port=5000, debug=False):": "Start the web server. This function does not normally return, as\n        the server enters an endless listening loop. The :func:`shutdown`\n        function provides a method for terminating the server gracefully.\n\n        :param host: The hostname or IP address of the network interface that\n                     will be listening for requests. A value of ``'0.0.0.0'``\n                     (the ",
    " shutdown(self):": "N/A",
    " dispatch_request(self, reader, writer):": "N/A",
    " _invoke_handler(self, f_or_coro, *args, **kwargs):": "N/A"
  },
  "./src/microdot.py": {
    "#!/usr/bin/env python": "\nmicrodot\n--------\n\nThe ``microdot`` module ",
    "ines a few classes that help implement HTTP-based": "\ntry:\n    from sys import print_exception\nexcept ImportError:  # pragma: no cover\n    import traceback\n\n    ",
    " print_exception(exc):": "N/A",
    " create_thread(f, *args, **kwargs):": "N/A",
    " run():": "N/A",
    " urldecode(string):": "A subclass of dictionary that can hold multiple values for the same\n    key. It is used to hold key/value pairs decoded from query strings and\n    form submissions.\n\n    :param initial_dict: an initial dictionary of key/value pairs to\n                         initialize this object with.\n\n    Example::\n\n        >>> d = MultiDict()\n        >>> d['sort'] = 'name'\n        >>> d['sort'] = 'email'\n        >>> print(d['sort'])\n        'name'\n        >>> print(d.getlist('sort'))\n        ['name', 'email']\n    ",
    " __init__(self, initial_dict=None):": "N/A",
    " __setitem__(self, key, value):": "N/A",
    " __getitem__(self, key):": "N/A",
    " get(self, key, ": "N/A",
    "ault=None, type=None):": "Return the value for a given key.\n\n        :param key: The key to retrieve.\n        :param ",
    "ault: A ": "N/A",
    "ault value to use if the key does not exist.": "N/A",
    "ault='noname')": "\n        if key not in self:\n            return ",
    "ault": "N/A",
    " getlist(self, key, type=None):": "Return all the values for a given key.\n\n        :param key: The key to retrieve.\n        :param type: A type conversion callable to apply to the values.\n\n        If the requested key does not exist in the dictionary, this method\n        returns an empty list.\n\n        Example::\n\n            >>> d = MultiDict()\n            >>> d.getlist('items')\n            []\n            >>> d['items'] = '3'\n            >>> d.getlist('items')\n            ['3']\n            >>> d['items'] = '56'\n            >>> d.getlist('items')\n            ['3', '56']\n            >>> d.getlist('items', type=int)\n            [3, 56]\n        ",
    " __init__(self, app, client_addr, method, url, http_version, headers,": "N/A",
    " create(app, client_stream, client_addr):": "Create a request object.\n\n        :param app: The Microdot application instance.\n        :param client_stream: An input stream from where the request data can\n                              be read.\n        :param client_addr: The address of the client, as a tuple.\n\n        This method returns a newly created ``Request`` object.\n        ",
    " _parse_urlencoded(self, urlencoded):": "N/A",
    " body(self):": "N/A",
    " stream(self):": "N/A",
    " json(self):": "N/A",
    " form(self):": "N/A",
    " _safe_readline(stream):": "An HTTP response class.\n\n    :param body: The body of the response. If a dictionary or list is given,\n                 a JSON formatter is used to generate the body.\n    :param status_code: The numeric HTTP status code of the response. The\n                        ",
    "ault is 200.": "N/A",
    "ault is \"OK\" for responses with a 200 status code and": "\n    types_map = {\n        'css': 'text/css',\n        'gif': 'image/gif',\n        'html': 'text/html',\n        'jpg': 'image/jpeg',\n        'js': 'application/javascript',\n        'json': 'application/json',\n        'png': 'image/png',\n        'txt': 'text/plain',\n    }\n    send_file_buffer_size = 1024\n\n    ",
    " __init__(self, body='', status_code=200, headers=None, reason=None):": "N/A",
    " set_cookie(self, cookie, value, path=None, domain=None, expires=None,": "Add a cookie to the response.\n\n        :param cookie: The cookie's name.\n        :param value: The cookie's value.\n        :param path: The cookie's path.\n        :param domain: The cookie's domain.\n        :param expires: The cookie expiration time, as a ``datetime`` object.\n        :param max_age: The cookie's ``Max-Age`` value.\n        :param secure: The cookie's ``secure`` flag.\n        :param http_only: The cookie's ``HttpOnly`` flag.\n        ",
    " complete(self):": "N/A",
    " write(self, stream):": "N/A",
    " redirect(cls, location, status_code=302):": "Return a redirect response.\n\n        :param location: The URL to redirect to.\n        :param status_code: The 3xx status code to use for the redirect. The\n                            ",
    "ault is 302.": "\n        if content_type is None:\n            ext = filename.split('.')[-1]\n            if ext in Response.types_map:\n                content_type = Response.types_map[ext]\n            else:\n                content_type = 'application/octet-stream'\n        f = open(filename, 'rb')\n        return cls(body=f, status_code=status_code,\n                   headers={'Content-Type': content_type})\n\n\nclass URLPattern():\n    ",
    " send_file(cls, filename, status_code=200, content_type=None):": "Send file contents in a response.\n\n        :param filename: The filename of the file.\n        :param status_code: The 3xx status code to use for the redirect. The\n                            ",
    " __init__(self, url_pattern):": "N/A",
    " match(self, path):": "An HTTP application class.\n\n    This class implements an HTTP application instance and is heavily\n    influenced by the ``Flask`` class of the Flask framework. It is typically\n    declared near the start of the main application script.\n\n    Example::\n\n        from microdot import Microdot\n\n        app = Microdot()\n    ",
    " __init__(self):": "N/A",
    " route(self, url_pattern, methods=None):": "Decorator that is used to register a function as a request handler\n        for a given URL.\n\n        :param url_pattern: The URL pattern that will be compared against\n                            incoming requests.\n        :param methods: The list of HTTP methods to be handled by the\n                        decorated function. If omitted, only ``GET`` requests\n                        are handled.\n\n        The URL pattern can be a static path (for example, ``/users`` or\n        ``/api/invoices/search``) or a path with dynamic components enclosed\n        in ``<`` and ``>`` (for example, ``/users/<id>`` or\n        ``/invoices/<number>/products``). Dynamic path components can also\n        include a type prefix, separated from the name with a colon (for\n        example, ``/users/<int:id>``). The type can be ``string`` (the\n        ",
    "ault), ``int``, ``path`` or ``re:[regular-expression]``.": "N/A",
    " index(request):": "\n        ",
    " decorated(f):": "N/A",
    " get(self, url_pattern):": "Decorator that is used to register a function as a ``GET`` request\n        handler for a given URL.\n\n        :param url_pattern: The URL pattern that will be compared against\n                            incoming requests.\n\n        This decorator can be used as an alias to the ``route`` decorator with\n        ``methods=['GET']``.\n\n        Example::\n\n            @app.get('/users/<int:id>')\n            ",
    " get_user(request, id):": "\n        return self.route(url_pattern, methods=['GET'])\n\n    ",
    " post(self, url_pattern):": "Decorator that is used to register a function as a ``POST`` request\n        handler for a given URL.\n\n        :param url_pattern: The URL pattern that will be compared against\n                            incoming requests.\n\n        This decorator can be used as an alias to the``route`` decorator with\n        ``methods=['POST']``.\n\n        Example::\n\n            @app.post('/users')\n            ",
    " create_user(request):": "\n        return self.route(url_pattern, methods=['POST'])\n\n    ",
    " put(self, url_pattern):": "Decorator that is used to register a function as a ``PUT`` request\n        handler for a given URL.\n\n        :param url_pattern: The URL pattern that will be compared against\n                            incoming requests.\n\n        This decorator can be used as an alias to the ``route`` decorator with\n        ``methods=['PUT']``.\n\n        Example::\n\n            @app.put('/users/<int:id>')\n            ",
    " edit_user(request, id):": "\n        return self.route(url_pattern, methods=['PATCH'])\n\n    ",
    " patch(self, url_pattern):": "Decorator that is used to register a function as a ``PATCH`` request\n        handler for a given URL.\n\n        :param url_pattern: The URL pattern that will be compared against\n                            incoming requests.\n\n        This decorator can be used as an alias to the ``route`` decorator with\n        ``methods=['PATCH']``.\n\n        Example::\n\n            @app.patch('/users/<int:id>')\n            ",
    " delete(self, url_pattern):": "Decorator that is used to register a function as a ``DELETE``\n        request handler for a given URL.\n\n        :param url_pattern: The URL pattern that will be compared against\n                            incoming requests.\n\n        This decorator can be used as an alias to the ``route`` decorator with\n        ``methods=['DELETE']``.\n\n        Example::\n\n            @app.delete('/users/<int:id>')\n            ",
    " delete_user(request, id):": "\n        return self.route(url_pattern, methods=['DELETE'])\n\n    ",
    " before_request(self, f):": "Decorator to register a function to run before each request is\n        handled. The decorated function must take a single argument, the\n        request object.\n\n        Example::\n\n            @app.before_request\n            ",
    " func(request):": "\n        self.before_request_handlers.append(f)\n        return f\n\n    ",
    " after_request(self, f):": "Decorator to register a function to run after each request is\n        handled. The decorated function must take two arguments, the request\n        and response objects. The return value of the function must be an\n        updated response object.\n\n        Example::\n\n            @app.before_request\n            ",
    " func(request, response):": "\n        self.after_request_handlers.append(f)\n        return f\n\n    ",
    " errorhandler(self, status_code_or_exception_class):": "Decorator to register a function as an error handler. Error handler\n        functions for numeric HTTP status codes must accept a single argument,\n        the request object. Error handler functions for Python exceptions\n        must accept two arguments, the request object and the exception\n        object.\n\n        :param status_code_or_exception_class: The numeric HTTP status code or\n                                               Python exception class to\n                                               handle.\n\n        Examples::\n\n            @app.errorhandler(404)\n            ",
    " not_found(request):": "N/A",
    " runtime_error(request, exception):": "\n        ",
    " run(self, host='0.0.0.0', port=5000, debug=False):": "Start the web server. This function does not normally return, as\n        the server enters an endless listening loop. The :func:`shutdown`\n        function provides a method for terminating the server gracefully.\n\n        :param host: The hostname or IP address of the network interface that\n                     will be listening for requests. A value of ``'0.0.0.0'``\n                     (the ",
    "ault) indicates that the server should listen for": "N/A",
    "ault is": "N/A",
    "ault is ``False``.": "N/A",
    " index():": "\n        self.debug = debug\n        self.shutdown_requested = False\n\n        self.server = socket.socket()\n        ai = socket.getaddrinfo(host, port)\n        addr = ai[0][-1]\n\n        if self.debug:  # pragma: no cover\n            print('Starting {mode} server on {host}:{port}...'.format(\n                mode=concurrency_mode, host=host, port=port))\n        self.server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.server.bind(addr)\n        self.server.listen(5)\n\n        while not self.shutdown_requested:\n            try:\n                sock, addr = self.server.accept()\n            except OSError as exc:  # pragma: no cover\n                if exc.args[0] == errno.ECONNABORTED:\n                    break\n                else:\n                    raise\n            create_thread(self.dispatch_request, sock, addr)\n\n    ",
    " shutdown(self):": "Request a server shutdown. The server will then exit its request\n        listening loop and the :func:`run` function will return. This function\n        can be safely called from a route handler, as it only schedules the\n        server to terminate as soon as the request completes.\n\n        Example::\n\n            @app.route('/shutdown')\n            ",
    " shutdown(request):": "\n        self.shutdown_requested = True\n\n    ",
    " find_route(self, req):": "N/A",
    " dispatch_request(self, sock, addr):": "N/A"
  },
  "./src/micro_func.py": {
    "#!/usr/bin/env python3": "micro_func provides some simple, pure functions, to make life easier",
    " DB(name=\"\", surround=(\"[\", \"] \"), debug=True, func=print):": "returns a debugger function - which is print by ",
    "ault -": "\n    if not debug:\n        return lambda x, _: None\n    return lambda m: func(surround[0] + name + surround[1], m)\n\n\n\n",
    " trying(exception, function, arg, on_fail=lambda a: None):": "tries to return function(arg),\n    returns on_fail(arg) if exception occures",
    " remove_chars(string, chars):": "N/A"
  },
  "./src/playground.py": {
    "#!/usr/bin/env python3": "N/A",
    " gpio_read():": "N/A",
    " ds18b20(pin, delay=5):": "https://randomnerdtutorials.com/micropython-ds18b20-esp32-esp8266/",
    " read_pin(pin):": "N/A"
  },
  "./src/pt100.py": {
    "from machine import ADC, Pin": "N/A",
    " __init__(self, pin):": "N/A",
    " comp(self, pt, i):": "N/A",
    " read(self):": "N/A"
  }
}